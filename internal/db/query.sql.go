// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package db

import (
	"context"
)

const createConversation = `-- name: CreateConversation :one
insert into conversation (topic) values ("") returning  id, topic, created_at
`

func (q *Queries) CreateConversation(ctx context.Context) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, createConversation)
	var i Conversation
	err := row.Scan(&i.ID, &i.Topic, &i.CreatedAt)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
insert into messages (user_id, conversation_id, content) values (?, ?, ?) returning id, conversation_id, user_id, content, created_at
`

type CreateMessageParams struct {
	UserID         int64
	ConversationID int64
	Content        string
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage, arg.UserID, arg.ConversationID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
insert into user (
  password, email, handle
) values (?1 , ?2, ?3) returning id, email, handle, password, created_at
`

type CreateUserParams struct {
	Password string
	Email    string
	Handle   string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Password, arg.Email, arg.Handle)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Handle,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const getAllUsers = `-- name: GetAllUsers :many
select id, email, handle, password, created_at from user
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Handle,
			&i.Password,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsForUser = `-- name: GetConversationsForUser :many
select m.content, m.id, m.user_id, u.handle, u.id 
from user_conversation uc, messages m, user u 
where uc.user_id = ? and uc.conversation_id = m.conversation_id and uc.user_id = u.id
`

type GetConversationsForUserRow struct {
	Content string
	ID      int64
	UserID  int64
	Handle  string
	ID_2    int64
}

func (q *Queries) GetConversationsForUser(ctx context.Context, userID int64) ([]GetConversationsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getConversationsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationsForUserRow
	for rows.Next() {
		var i GetConversationsForUserRow
		if err := rows.Scan(
			&i.Content,
			&i.ID,
			&i.UserID,
			&i.Handle,
			&i.ID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsList = `-- name: GetConversationsList :many
select
  uc.conversation_id, 
u.handle,
u.id as user_id,
  json_group_array(json_object(
    'message_id', m.id,
    'content', m.content,
    'user_id', m.user_id,
    'handle', m.handle,
    'created_at', m.created_at
   )) as conversation_messages
   
from
  user_conversation uc
    join (select messages.id, messages.created_at, messages.conversation_id, messages.content, messages.user_id, u.handle from messages, user u where u.id = messages.user_id  order by messages.created_at desc) as m on m.conversation_id = uc.conversation_id
    -- get the other user in the conversation who is NOT me.
    
    join user u on uc.user_id = u.id 
    where uc.user_id = ?
    group by uc.conversation_id
order by
  uc.conversation_id
limit
  10
`

type GetConversationsListRow struct {
	ConversationID       int64
	Handle               string
	UserID               int64
	ConversationMessages interface{}
}

func (q *Queries) GetConversationsList(ctx context.Context, userID int64) ([]GetConversationsListRow, error) {
	rows, err := q.db.QueryContext(ctx, getConversationsList, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationsListRow
	for rows.Next() {
		var i GetConversationsListRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.Handle,
			&i.UserID,
			&i.ConversationMessages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOtherConversationUser = `-- name: GetOtherConversationUser :one
select u.id, u.handle from user u, user_conversation uc where u.id = uc.user_id and uc.conversation_id=? and u.id != ? limit 1
`

type GetOtherConversationUserParams struct {
	ConversationID int64
	ID             int64
}

type GetOtherConversationUserRow struct {
	ID     int64
	Handle string
}

func (q *Queries) GetOtherConversationUser(ctx context.Context, arg GetOtherConversationUserParams) (GetOtherConversationUserRow, error) {
	row := q.db.QueryRowContext(ctx, getOtherConversationUser, arg.ConversationID, arg.ID)
	var i GetOtherConversationUserRow
	err := row.Scan(&i.ID, &i.Handle)
	return i, err
}

const getTotalNumMessages = `-- name: GetTotalNumMessages :one
select count(id) from messages
`

func (q *Queries) GetTotalNumMessages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalNumMessages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
select id, email, handle, password, created_at from user 
where email = ?1 limit 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Handle,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const linkUserToConversation = `-- name: LinkUserToConversation :one
insert into user_conversation (user_id, conversation_id) values (?, ?) returning user_id, conversation_id
`

type LinkUserToConversationParams struct {
	UserID         int64
	ConversationID int64
}

func (q *Queries) LinkUserToConversation(ctx context.Context, arg LinkUserToConversationParams) (UserConversation, error) {
	row := q.db.QueryRowContext(ctx, linkUserToConversation, arg.UserID, arg.ConversationID)
	var i UserConversation
	err := row.Scan(&i.UserID, &i.ConversationID)
	return i, err
}

const newQueryName = `-- name: NewQueryName :many
select u.id from user u where u.id > ?1 and (?2 IS NULL or u.email = ?2)
`

type NewQueryNameParams struct {
	ID      int64
	Column2 interface{}
}

func (q *Queries) NewQueryName(ctx context.Context, arg NewQueryNameParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, newQueryName, arg.ID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const possibleConversationUsers = `-- name: PossibleConversationUsers :many
select u.id, u.handle from user u where u.id not in (
select uc.user_id from user_conversation uc where uc.conversation_id in (
  select  user_conversation.conversation_id 
        from user_conversation 
        where user_conversation.user_id = ?1)
and uc.user_id != ?1)
and u.id != ?1
`

type PossibleConversationUsersRow struct {
	ID     int64
	Handle string
}

func (q *Queries) PossibleConversationUsers(ctx context.Context, userID int64) ([]PossibleConversationUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, possibleConversationUsers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PossibleConversationUsersRow
	for rows.Next() {
		var i PossibleConversationUsersRow
		if err := rows.Scan(&i.ID, &i.Handle); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
