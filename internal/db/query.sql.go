// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package db

import (
	"context"
)

const createConversation = `-- name: CreateConversation :one
insert into conversation (topic) values ("") returning  id, topic, created_at
`

func (q *Queries) CreateConversation(ctx context.Context) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, createConversation)
	var i Conversation
	err := row.Scan(&i.ID, &i.Topic, &i.CreatedAt)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
insert into messages (user_id, conversation_id, content) values (?, ?, ?) returning id, conversation_id, user_id, content, created_at
`

type CreateMessageParams struct {
	UserID         int64
	ConversationID int64
	Content        string
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage, arg.UserID, arg.ConversationID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
insert into user (
  password, email, handle
) values (? , ?, ?) returning id, email, handle, password, created_at
`

type CreateUserParams struct {
	Password string
	Email    string
	Handle   string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Password, arg.Email, arg.Handle)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Handle,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const getAllUsers = `-- name: GetAllUsers :many
select id, email, handle, password, created_at from user
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Handle,
			&i.Password,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsForUser = `-- name: GetConversationsForUser :many
select m.content, m.id, m.user_id, u.handle, u.id 
from user_conversation uc, messages m, user u 
where uc.user_id = ? and uc.conversation_id = m.conversation_id and uc.user_id = u.id
`

type GetConversationsForUserRow struct {
	Content string
	ID      int64
	UserID  int64
	Handle  string
	ID_2    int64
}

func (q *Queries) GetConversationsForUser(ctx context.Context, userID int64) ([]GetConversationsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getConversationsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationsForUserRow
	for rows.Next() {
		var i GetConversationsForUserRow
		if err := rows.Scan(
			&i.Content,
			&i.ID,
			&i.UserID,
			&i.Handle,
			&i.ID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsList = `-- name: GetConversationsList :many
select
  uc.conversation_id, 
u.handle,
u.id as user_id,
  json_group_array(json_object(
    'message_id', m.id,
    'content', m.content,
    'user_id', m.user_id,
    'handle', m.handle,
    'created_at', m.created_at
   )) as conversation_messages
   
from
  user_conversation uc
    join (select messages.id, messages.created_at, messages.conversation_id, messages.content, messages.user_id, u.handle from messages, user u where u.id = messages.user_id  order by messages.created_at desc) as m on m.conversation_id = uc.conversation_id
    -- join  (select uconv.conversation_id, uconv.user_id, u.handle from user u, user_conversation uconv where uconv.user_id != u.id and uconv.conversation_id = uc.conversation_id) as uconv on uc.conversation_id = uconv.conversation_id
    join user u on uc.user_id = u.id 
    where uc.user_id = ?
    group by uc.conversation_id
order by
  uc.conversation_id
limit
  10
`

type GetConversationsListRow struct {
	ConversationID       int64
	Handle               string
	UserID               int64
	ConversationMessages interface{}
}

func (q *Queries) GetConversationsList(ctx context.Context, userID int64) ([]GetConversationsListRow, error) {
	rows, err := q.db.QueryContext(ctx, getConversationsList, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationsListRow
	for rows.Next() {
		var i GetConversationsListRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.Handle,
			&i.UserID,
			&i.ConversationMessages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
select id, email, handle, password, created_at from user 
where email = ? limit 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Handle,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const linkUserToConversation = `-- name: LinkUserToConversation :one
insert into user_conversation (user_id, conversation_id) values (?, ?) returning user_id, conversation_id
`

type LinkUserToConversationParams struct {
	UserID         int64
	ConversationID int64
}

func (q *Queries) LinkUserToConversation(ctx context.Context, arg LinkUserToConversationParams) (UserConversation, error) {
	row := q.db.QueryRowContext(ctx, linkUserToConversation, arg.UserID, arg.ConversationID)
	var i UserConversation
	err := row.Scan(&i.UserID, &i.ConversationID)
	return i, err
}
